{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/BondToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./interfaces/HubPoolInterface.sol\";\nimport \"./external/WETH9.sol\";\n\ninterface ExtendedHubPoolInterface is HubPoolInterface {\n    // Specify the automatically-implemented rootBundleProposal() getter.\n    function rootBundleProposal() external pure returns (HubPoolInterface.RootBundle memory);\n}\n\n/**\n * @notice Across Bond Token (ABT).\n * ABT is a simple deposit contract based on WETH9. ABT is issued proportionally to any address that deposits Ether. It\n * imposes address-based permissioning on the WETH9 transferFrom() function in order to constrain the movement of ABT\n * into the Across v2 HubPool contract. When configured as the required HubPool bond token, ABT can dramatically reduce\n * the attack surface of the HubPool by requiring that addresses are explicitly approved before they can successfully\n * submit a root bundle proposal. The address-based permissioning does not constrain transfers that are needed to dispute\n * a root bundle proposal, so the ability of decentralised/unknown actors to dispute is unaffected.\n */\ncontract BondToken is WETH9, Ownable {\n    using Address for address;\n\n    ExtendedHubPoolInterface public immutable hubPool;\n\n    /**\n     * @notice Addresses that are permitted to make HubPool root bundle proposals.\n     */\n    mapping(address => bool) public proposers;\n\n    /**\n     * @notice Emitted on proposer permissions update.\n     */\n    event ProposerModified(address proposer, bool enabled);\n\n    /**\n     * @notice BondToken constructor.\n     * @param _hubPool Address of the target HubPool contract.\n     */\n    constructor(ExtendedHubPoolInterface _hubPool) {\n        name = \"Across Bond Token\";\n        symbol = \"ABT\";\n        hubPool = _hubPool;\n    }\n\n    /**\n     * @notice Enable or disable an address as an allowed proposer. Emits a \"ProposerModified\" event on completion.\n     * @param proposer Proposer address to modify.\n     * @param enabled Boolean controlling whether the address is permitted to propose.\n     */\n    function setProposer(address proposer, bool enabled) external onlyOwner {\n        proposers[proposer] = enabled;\n        emit ProposerModified(proposer, enabled);\n    }\n\n    /**\n     * @notice Transfer amt from src to dst. Prevents unauthorised root bundle proposals by blocking transfers to the\n     * HubPool under the following conditions:\n     * - The src address is not a pre-approved proposer, *and*\n     * - The src address is the current proposer of a HubPool root bundle.\n     * Falls back to the base implementation after verifying that the transfer is permitted.\n     * @dev The require(..., \"Transfer not permitted\") statement is dependent on the internal ordering of HubPool\n     * proposedRootBundle state variable updates, relative to calling bondToken.safeTransferFrom(). Changing the order\n     * of HubPool actions may invalidate this verification. BondToken tests are implemented to detect this.\n     * @param src Source address.\n     * @param dst Destination address.\n     * @param amt Amount to transfer.\n     * @return True on success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) public override returns (bool) {\n        if (dst == address(hubPool)) {\n            require(proposers[src] || hubPool.rootBundleProposal().proposer != src, \"Transfer not permitted\");\n        }\n        return super.transferFrom(src, dst, amt);\n    }\n}\n"
    },
    "contracts/external/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/**\n * Copyright (C) 2015, 2016, 2017 Dapphub\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Imported as at commit 33d01d471437e1ab6861e4545ea4bb3895fd4d74 from:\n * UMAprotocol/protocol/packages/core/contracts/financial-templates/common/WETH9.sol\n * Changes applied post-import:\n * - Corrected SPDX-License-Identifier & reinstated GPLv3 license header.\n * - Permit transferFrom() to be overridden by marking it virtual.\n */\n\npragma solidity ^0.8.0;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    fallback() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev Local change: marked virtual to allow overriding.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/interfaces/HubPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Concise list of functions in HubPool implementation.\n */\ninterface HubPoolInterface {\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\n    struct PoolRebalanceLeaf {\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\n        uint256 chainId;\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\n        uint256[] bundleLpFees;\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\n        int256[] netSendAmounts;\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\n        int256[] runningBalances;\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\n        // leaf for a specific chainId should have a groupIndex equal to 0.\n        uint256 groupIndex;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint8 leafId;\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\n        // relays on this chain in this bundle in the order of whitelisting.\n        address[] l1Tokens;\n    }\n\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\n    // that can be executed later to:\n    // - Send funds from this contract to a SpokePool or vice versa\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \"slow\" relay\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\n    struct RootBundle {\n        // Contains leaves instructing this contract to send funds to SpokePools.\n        bytes32 poolRebalanceRoot;\n        // Relayer refund merkle root to be published to a SpokePool.\n        bytes32 relayerRefundRoot;\n        // Slow relay merkle root to be published to a SpokePool.\n        bytes32 slowRelayRoot;\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\n        uint256 claimedBitMap;\n        // Proposer of this root bundle.\n        address proposer;\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\n        // of leaves are executed, a new root bundle can be proposed\n        uint8 unclaimedPoolRebalanceLeafCount;\n        // When root bundle challenge period passes and this root bundle becomes executable.\n        uint32 challengePeriodEndTimestamp;\n    }\n\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\n    // cumulative LP positions and if this token is enabled for deposits.\n    struct PooledToken {\n        // LP token given to LPs of a specific L1 token.\n        address lpToken;\n        // True if accepting new LP's.\n        bool isEnabled;\n        // Timestamp of last LP fee update.\n        uint32 lastLpFeeUpdate;\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\n        // back later.\n        int256 utilizedReserves;\n        // Number of LP funds held in contract less utilized reserves.\n        uint256 liquidReserves;\n        // Number of LP funds reserved to pay out to LPs as fees.\n        uint256 undistributedLpFees;\n    }\n\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\n    struct CrossChainContract {\n        address adapter;\n        address spokePool;\n    }\n\n    function setPaused(bool pause) external;\n\n    function emergencyDeleteProposal() external;\n\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\n\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\n\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\n\n    function setLiveness(uint32 newLiveness) external;\n\n    function setIdentifier(bytes32 newIdentifier) external;\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) external;\n\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\n\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) external;\n\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\n\n    function sync(address l1Token) external;\n\n    function proposeRootBundle(\n        uint256[] memory bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayRoot\n    ) external;\n\n    function executeRootBundle(\n        uint256 chainId,\n        uint256 groupIndex,\n        uint256[] memory bundleLpFees,\n        int256[] memory netSendAmounts,\n        int256[] memory runningBalances,\n        uint8 leafId,\n        address[] memory l1Tokens,\n        bytes32[] memory proof\n    ) external;\n\n    function disputeRootBundle() external;\n\n    function claimProtocolFeesCaptured(address l1Token) external;\n\n    function setPoolRebalanceRoute(\n        uint256 destinationChainId,\n        address l1Token,\n        address destinationToken\n    ) external;\n\n    function setDepositRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        bool depositsEnabled\n    ) external;\n\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\n        external\n        view\n        returns (address destinationToken);\n\n    function loadEthForL2Calls() external payable;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
